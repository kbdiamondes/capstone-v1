{"ast":null,"code":"function findTopStateForTarget(state) {\n  var _current5, _current5$routes;\n  var current = state;\n  var previous = state;\n  while (((_current = current) == null ? void 0 : (_current$routes = _current.routes) == null ? void 0 : _current$routes[((_current2 = current) == null ? void 0 : (_current2$routes = _current2.routes) == null ? void 0 : _current2$routes.length) - 1].state) != null) {\n    var _current, _current$routes, _current2, _current2$routes, _current3, _current4;\n    previous = current;\n    current = (_current3 = current) == null ? void 0 : _current3.routes[((_current4 = current) == null ? void 0 : _current4.routes.length) - 1].state;\n  }\n  if (previous && ((_current5 = current) == null ? void 0 : (_current5$routes = _current5.routes) == null ? void 0 : _current5$routes[current.routes.length - 1].name) === \"index\") {\n    return previous;\n  }\n  return current;\n}\nexport function findTopRouteForTarget(state) {\n  var _nextState$routes;\n  var nextState = findTopStateForTarget(state);\n  return (_nextState$routes = nextState.routes) == null ? void 0 : _nextState$routes[nextState.routes.length - 1];\n}\nexport function isMovingToSiblingRoute(currentState, targetState) {\n  var _currentState$routeNa;\n  if (!currentState || !targetState) {\n    return false;\n  }\n  var targetRoute = targetState.routes[0];\n  if (!((_currentState$routeNa = currentState.routeNames) != null && _currentState$routeNa.includes(targetRoute.name))) {\n    return false;\n  }\n  if (!targetRoute.state) {\n    return true;\n  }\n  var currentRoutes = currentState == null ? void 0 : currentState.routes;\n  var locatedState = currentRoutes == null ? void 0 : currentRoutes.find(function (r) {\n    return r.name === targetRoute.name;\n  });\n  if (!locatedState) {\n    return false;\n  }\n  return isMovingToSiblingRoute(locatedState.state, targetRoute.state);\n}\nexport function getQualifiedStateForTopOfTargetState(rootState, targetState) {\n  var current = targetState;\n  var currentRoot = rootState;\n  var _loop = function _loop() {\n    var _current8, _current8$routes, _current9, _current9$routes, _currentRoot, _currentRoot$routes, _currentRoot$routes$f;\n    var nextRoute = (_current8 = current) == null ? void 0 : (_current8$routes = _current8.routes) == null ? void 0 : _current8$routes[((_current9 = current) == null ? void 0 : (_current9$routes = _current9.routes) == null ? void 0 : _current9$routes.length) - 1];\n    var nextCurrentRoot = (_currentRoot = currentRoot) == null ? void 0 : (_currentRoot$routes = _currentRoot.routes) == null ? void 0 : (_currentRoot$routes$f = _currentRoot$routes.find(function (route) {\n      return route.name === nextRoute.name;\n    })) == null ? void 0 : _currentRoot$routes$f.state;\n    if (nextCurrentRoot == null) {\n      return {\n        v: currentRoot\n      };\n    } else {\n      currentRoot = nextCurrentRoot;\n    }\n    current = nextRoute.state;\n  };\n  while (((_current6 = current) == null ? void 0 : (_current6$routes = _current6.routes) == null ? void 0 : _current6$routes[((_current7 = current) == null ? void 0 : (_current7$routes = _current7.routes) == null ? void 0 : _current7$routes.length) - 1].state) != null) {\n    var _current6, _current6$routes, _current7, _current7$routes;\n    var _ret = _loop();\n    if (typeof _ret === \"object\") return _ret.v;\n  }\n  return currentRoot;\n}\nexport function getEarliestMismatchedRoute(rootState, actionParams) {\n  var _actionParams$name;\n  var actionName = (_actionParams$name = actionParams.name) != null ? _actionParams$name : actionParams.screen;\n  if (!(rootState != null && rootState.routes) || rootState.index == null) {\n    return {\n      name: actionName,\n      type: \"stack\"\n    };\n  }\n  var nextCurrentRoot = rootState.routes[rootState.index];\n  if (actionName === nextCurrentRoot.name) {\n    if (!actionParams.params) {\n      return null;\n    }\n    return getEarliestMismatchedRoute(nextCurrentRoot.state, actionParams.params);\n  }\n  return {\n    name: actionName,\n    params: actionParams.params,\n    type: rootState.type\n  };\n}","map":{"version":3,"names":["findTopStateForTarget","state","_current5","_current5$routes","current","previous","_current","_current$routes","routes","_current2","_current2$routes","length","_current3","_current4","name","findTopRouteForTarget","_nextState$routes","nextState","isMovingToSiblingRoute","currentState","targetState","_currentState$routeNa","targetRoute","routeNames","includes","currentRoutes","locatedState","find","r","getQualifiedStateForTopOfTargetState","rootState","currentRoot","_loop","_current8","_current8$routes","_current9","_current9$routes","_currentRoot","_currentRoot$routes","_currentRoot$routes$f","nextRoute","nextCurrentRoot","route","v","_current6","_current6$routes","_current7","_current7$routes","_ret","getEarliestMismatchedRoute","actionParams","_actionParams$name","actionName","screen","index","type","params"],"sources":["C:/Users/User/Documents/GitHub/Capstone/collectify/collectify-front-end/node_modules/expo-router/src/link/stateOperations.ts"],"sourcesContent":["import {\r\n  InitialState,\r\n  NavigationState,\r\n  ParamListBase,\r\n  PartialState,\r\n  getActionFromState,\r\n} from \"@react-navigation/native\";\r\n\r\nimport { ResultState } from \"../fork/getStateFromPath\";\r\n\r\nexport type NavigateAction = Extract<\r\n  ReturnType<typeof getActionFromState>,\r\n  { type: \"NAVIGATE\" }\r\n> & {\r\n  payload: NavigateActionParams;\r\n};\r\n\r\nexport type NavigateActionParams = {\r\n  params?: NavigateActionParams;\r\n  path: string;\r\n  initial: boolean;\r\n  screen: string;\r\n  name?: string;\r\n};\r\n\r\n// Get the last state for a given target state (generated from a path).\r\nfunction findTopStateForTarget(state: ResultState) {\r\n  let current: Partial<InitialState> | undefined = state;\r\n  let previous: Partial<InitialState> | undefined = state;\r\n\r\n  while (current?.routes?.[current?.routes?.length - 1].state != null) {\r\n    previous = current;\r\n    current = current?.routes[current?.routes.length - 1].state;\r\n  }\r\n\r\n  // If the last route in the target state is an index route, return the previous state (parent).\r\n  // NOTE: This may need to be updated to support initial route name being a non-standard value.\r\n  if (\r\n    previous &&\r\n    current?.routes?.[current.routes.length - 1]!.name === \"index\"\r\n  ) {\r\n    return previous;\r\n  }\r\n\r\n  return current;\r\n}\r\n\r\n/** Return the absolute last route to move to. */\r\nexport function findTopRouteForTarget(state: ResultState) {\r\n  const nextState = findTopStateForTarget(state)!;\r\n  // Ensure we get the last route to prevent returning the initial route.\r\n  return nextState.routes?.[nextState.routes.length - 1]!;\r\n}\r\n\r\n/** @returns true if moving to a sibling inside the same navigator. */\r\nexport function isMovingToSiblingRoute(\r\n  currentState: NavigationState | PartialState<NavigationState> | undefined,\r\n  targetState: ResultState | undefined\r\n): boolean {\r\n  if (!currentState || !targetState) {\r\n    return false;\r\n  }\r\n\r\n  // Need to type this, as the current types are not compaitble with the `find`\r\n  const targetRoute = targetState.routes[0];\r\n\r\n  // Make sure we're in the same navigator\r\n  if (!currentState.routeNames?.includes(targetRoute.name)) {\r\n    return false;\r\n  }\r\n\r\n  // If there's no state, we're at the end of the path\r\n  if (!targetRoute.state) {\r\n    return true;\r\n  }\r\n\r\n  // Coerce the types into a more common form\r\n  const currentRoutes:\r\n    | {\r\n        name: string;\r\n        state?: NavigationState | PartialState<NavigationState>;\r\n      }[]\r\n    | undefined = currentState?.routes;\r\n  const locatedState = currentRoutes?.find((r) => r.name === targetRoute.name);\r\n\r\n  if (!locatedState) {\r\n    return false;\r\n  }\r\n\r\n  return isMovingToSiblingRoute(locatedState.state, targetRoute.state);\r\n}\r\n\r\n// Given the root state and a target state from `getStateFromPath`,\r\n// return the root state containing the highest target route matching the root state.\r\n// This can be used to determine what type of navigator action should be used.\r\nexport function getQualifiedStateForTopOfTargetState(\r\n  rootState: InitialState,\r\n  targetState: ResultState\r\n) {\r\n  let current: InitialState | undefined = targetState;\r\n  let currentRoot: InitialState | undefined = rootState;\r\n\r\n  while (current?.routes?.[current?.routes?.length - 1].state != null) {\r\n    const nextRoute: any = current?.routes?.[current?.routes?.length - 1];\r\n\r\n    const nextCurrentRoot: InitialState | undefined = currentRoot?.routes?.find(\r\n      (route) => route.name === nextRoute.name\r\n    )?.state;\r\n\r\n    if (nextCurrentRoot == null) {\r\n      return currentRoot;\r\n      // Not sure what to do -- we're tracking against the assumption that\r\n      // all routes in the target state are in the root state\r\n      // currentRoot = undefined;\r\n    } else {\r\n      currentRoot = nextCurrentRoot;\r\n    }\r\n\r\n    current = nextRoute.state;\r\n  }\r\n\r\n  return currentRoot;\r\n}\r\n\r\n// Given the root state and a target state from `getStateFromPath`,\r\n// return the root state containing the highest target route matching the root state.\r\n// This can be used to determine what type of navigator action should be used.\r\nexport function getEarliestMismatchedRoute<T extends ParamListBase>(\r\n  rootState: NavigationState<T> | undefined,\r\n  actionParams: NavigateActionParams\r\n): { name: string; params?: any; type?: string } | null {\r\n  const actionName = actionParams.name ?? actionParams.screen;\r\n  if (!rootState?.routes || rootState.index == null) {\r\n    // This should never happen where there's more action than state.\r\n    return {\r\n      name: actionName,\r\n      type: \"stack\",\r\n    };\r\n  }\r\n\r\n  const nextCurrentRoot = rootState.routes[rootState.index];\r\n  if (actionName === nextCurrentRoot.name) {\r\n    if (!actionParams.params) {\r\n      // All routes match all the way up, no change required.\r\n      return null;\r\n    }\r\n\r\n    return getEarliestMismatchedRoute(\r\n      // @react-navigation/native types this as NavigationState | Partial<NavigationState> | undefined\r\n      // In our usage, it's always a NavigationState | undefined\r\n      nextCurrentRoot.state as NavigationState<T> | undefined,\r\n      actionParams.params\r\n    );\r\n  }\r\n\r\n  // There's a selected state but it doesn't match the action state\r\n  // this is now the lowest point of change.\r\n  return {\r\n    name: actionName,\r\n    params: actionParams.params,\r\n    type: rootState.type,\r\n  };\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport escape from \"escape-string-regexp\";\nimport * as queryString from \"query-string\";\nimport URL from \"url-parse\";\nimport { matchGroupName, stripGroupSegmentsFromPath } from \"../matchers\";\nimport { findFocusedRoute } from \"./findFocusedRoute\";\nimport validatePathConfig from \"./validatePathConfig\";\nexport function getUrlWithReactNavigationConcessions(path) {\n  var parsed = new URL(path, \"https://acme.com\");\n  var pathname = parsed.pathname;\n  return {\n    nonstandardPathname: pathname.replace(/^\\/+/g, \"\").replace(/\\/+$/g, \"\") + \"/\",\n    inputPathnameWithoutHash: path.replace(/#.*$/, \"\")\n  };\n}\nexport default function getStateFromPath(path, options) {\n  var _getMatchableRouteCon = getMatchableRouteConfigs(options),\n    initialRoutes = _getMatchableRouteCon.initialRoutes,\n    configs = _getMatchableRouteCon.configs;\n  return getStateFromPathWithConfigs(path, configs, initialRoutes);\n}\nexport function getMatchableRouteConfigs(options) {\n  if (options) {\n    validatePathConfig(options);\n  }\n  var screens = options == null ? void 0 : options.screens;\n  if (!screens) {\n    throw Error(\"You must pass a 'screens' object to 'getStateFromPath' to generate a path.\");\n  }\n  var initialRoutes = [];\n  if (options != null && options.initialRouteName) {\n    initialRoutes.push({\n      initialRouteName: options.initialRouteName,\n      parentScreens: []\n    });\n  }\n  var converted = Object.keys(screens).map(function (key) {\n    return createNormalizedConfigs(key, screens, [], initialRoutes);\n  }).flat();\n  var resolvedInitialPatterns = initialRoutes.map(function (route) {\n    return joinPaths.apply(void 0, _toConsumableArray(route.parentScreens).concat([route.initialRouteName]));\n  });\n  var convertedWithInitial = converted.map(function (config) {\n    return _objectSpread(_objectSpread({}, config), {}, {\n      isInitial: resolvedInitialPatterns.includes(config.routeNames.join(\"/\"))\n    });\n  });\n  var configs = convertedWithInitial.sort(sortConfigs);\n  assertConfigDuplicates(configs);\n  return {\n    configs: configs,\n    initialRoutes: initialRoutes\n  };\n}\nfunction assertConfigDuplicates(configs) {\n  configs.reduce(function (acc, config) {\n    var _config$regex$toStrin, _config$regex;\n    var indexedKey = (_config$regex$toStrin = (_config$regex = config.regex) == null ? void 0 : _config$regex.toString()) != null ? _config$regex$toStrin : config.pattern;\n    var alpha = acc[indexedKey];\n    if (alpha && !alpha.hasChildren && !config.hasChildren) {\n      var a = alpha.routeNames;\n      var b = config.routeNames;\n      var intersects = a.length > b.length ? b.every(function (it, i) {\n        return a[i] === it;\n      }) : a.every(function (it, i) {\n        return b[i] === it;\n      });\n      if (!intersects) {\n        var last = config.pattern.split(\"/\").pop();\n        var routeType = last != null && last.startsWith(\":\") ? \"dynamic route\" : last != null && last.startsWith(\"*\") ? \"dynamic-rest route\" : \"route\";\n        throw new Error(`The ${routeType} pattern '${config.pattern || \"/\"}' resolves to both '${alpha.userReadableName}' and '${config.userReadableName}'. Patterns must be unique and cannot resolve to more than one route.`);\n      }\n    }\n    return Object.assign(acc, _defineProperty({}, indexedKey, config));\n  }, {});\n}\nfunction sortConfigs(a, b) {\n  if (a.pattern === b.pattern) {\n    return b.routeNames.join(\">\").localeCompare(a.routeNames.join(\">\"));\n  }\n  if (a.pattern.startsWith(b.pattern) && b.screen !== \"index\") {\n    return -1;\n  }\n  if (b.pattern.startsWith(a.pattern) && a.screen !== \"index\") {\n    return 1;\n  }\n  var aParts = a.pattern.split(\"/\").filter(function (part) {\n    return matchGroupName(part) == null;\n  });\n  if (a.screen === \"index\") {\n    aParts.push(\"index\");\n  }\n  var bParts = b.pattern.split(\"/\").filter(function (part) {\n    return matchGroupName(part) == null;\n  });\n  if (b.screen === \"index\") {\n    bParts.push(\"index\");\n  }\n  for (var i = 0; i < Math.max(aParts.length, bParts.length); i++) {\n    if (aParts[i] == null) {\n      return 1;\n    }\n    if (bParts[i] == null) {\n      return -1;\n    }\n    var aWildCard = aParts[i].startsWith(\"*\");\n    var bWildCard = bParts[i].startsWith(\"*\");\n    if (aWildCard && bWildCard) {\n      continue;\n    }\n    if (aWildCard) {\n      return 1;\n    }\n    if (bWildCard) {\n      return -1;\n    }\n    var aSlug = aParts[i].startsWith(\":\");\n    var bSlug = bParts[i].startsWith(\":\");\n    if (aSlug && bSlug) {\n      continue;\n    }\n    if (aSlug) {\n      return 1;\n    }\n    if (bSlug) {\n      return -1;\n    }\n  }\n  if (a.isInitial && !b.isInitial) {\n    return -1;\n  }\n  if (!a.isInitial && b.isInitial) {\n    return 1;\n  }\n  return bParts.length - aParts.length;\n}\nfunction getStateFromEmptyPathWithConfigs(path, configs, initialRoutes) {\n  var _ref, _leafNodes$find;\n  var leafNodes = configs.filter(function (config) {\n    return !config.hasChildren;\n  }).map(function (value) {\n    return _objectSpread(_objectSpread({}, value), {}, {\n      path: stripGroupSegmentsFromPath(value.path)\n    });\n  });\n  var match = (_ref = (_leafNodes$find = leafNodes.find(function (config) {\n    return config.path === \"\" && (!config.regex || config.regex.test(\"\"));\n  })) != null ? _leafNodes$find : leafNodes.find(function (config) {\n    return config.path.startsWith(\":\") && config.regex.test(\"\");\n  })) != null ? _ref : leafNodes.find(function (config) {\n    return config.path.startsWith(\"*\") && config.regex.test(\"/\");\n  });\n  if (!match) {\n    return undefined;\n  }\n  var routes = match.routeNames.map(function (name) {\n    if (!match._route) {\n      return {\n        name: name\n      };\n    }\n    return {\n      name: name,\n      _route: match._route\n    };\n  });\n  return createNestedStateObject(path, routes, configs, initialRoutes);\n}\nfunction getStateFromPathWithConfigs(path, configs, initialRoutes) {\n  var formattedPaths = getUrlWithReactNavigationConcessions(path);\n  if (formattedPaths.nonstandardPathname === \"/\") {\n    return getStateFromEmptyPathWithConfigs(formattedPaths.inputPathnameWithoutHash, configs, initialRoutes);\n  }\n  var routes = matchAgainstConfigs(formattedPaths.nonstandardPathname, configs);\n  if (routes == null) {\n    return undefined;\n  }\n  return createNestedStateObject(formattedPaths.inputPathnameWithoutHash, routes, configs, initialRoutes);\n}\nvar joinPaths = function joinPaths() {\n  var _ref2;\n  for (var _len = arguments.length, paths = new Array(_len), _key = 0; _key < _len; _key++) {\n    paths[_key] = arguments[_key];\n  }\n  return (_ref2 = []).concat.apply(_ref2, _toConsumableArray(paths.map(function (p) {\n    return p.split(\"/\");\n  }))).filter(Boolean).join(\"/\");\n};\nfunction matchAgainstConfigs(remaining, configs) {\n  var routes;\n  var remainingPath = remaining;\n  var _loop = function _loop(config) {\n    var _config$pattern;\n    if (!config.regex) {\n      return \"continue\";\n    }\n    var match = remainingPath.match(config.regex);\n    if (!match) {\n      return \"continue\";\n    }\n    var matchedParams = (_config$pattern = config.pattern) == null ? void 0 : _config$pattern.split(\"/\").filter(function (p) {\n      return p.match(/^[:*]/);\n    }).reduce(function (acc, p, i) {\n      var _ref3;\n      if (p.match(/^\\*/)) {\n        return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, p, match[(i + 1) * 2]));\n      }\n      return Object.assign(acc, _defineProperty({}, p, (_ref3 = match[(i + 1) * 2]) == null ? void 0 : _ref3.replace(/\\//, \"\")));\n    }, {});\n    var routeFromName = function routeFromName(name) {\n      var config = configs.find(function (c) {\n        return c.screen === name;\n      });\n      if (!(config != null && config.path)) {\n        return {\n          name: name\n        };\n      }\n      var segments = config.path.split(\"/\");\n      var params = {};\n      segments.filter(function (p) {\n        return p.match(/^[:*]/);\n      }).forEach(function (p) {\n        var value = matchedParams[p];\n        if (value) {\n          var _config$parse;\n          if (p.match(/^\\*/)) {\n            var _value;\n            value = (_value = value) == null ? void 0 : _value.split(\"/\").filter(Boolean);\n          }\n          var key = p.replace(/^[:*]/, \"\").replace(/\\?$/, \"\");\n          params[key] = (_config$parse = config.parse) != null && _config$parse[key] ? config.parse[key](value) : value;\n        }\n      });\n      if (params && Object.keys(params).length) {\n        return {\n          name: name,\n          params: params\n        };\n      }\n      return {\n        name: name\n      };\n    };\n    routes = config.routeNames.map(function (name) {\n      if (!config._route) {\n        return _objectSpread({}, routeFromName(name));\n      }\n      return _objectSpread(_objectSpread({}, routeFromName(name)), {}, {\n        _route: config._route\n      });\n    });\n    var combinedParams = routes.reduce(function (acc, r) {\n      return Object.assign(acc, r.params);\n    }, {});\n    var hasCombinedParams = Object.keys(combinedParams).length > 0;\n    routes = routes.map(function (r) {\n      if (hasCombinedParams) {\n        r.params = combinedParams;\n      }\n      return r;\n    });\n    remainingPath = remainingPath.replace(match[1], \"\");\n    return \"break\";\n  };\n  for (var config of configs) {\n    var _ret = _loop(config);\n    if (_ret === \"continue\") continue;\n    if (_ret === \"break\") break;\n  }\n  return routes;\n}\nfunction equalHeritage(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (var i = 0; i < a.length; i++) {\n    if (a[i].localeCompare(b[i]) !== 0) {\n      return false;\n    }\n  }\n  return true;\n}\nvar createNormalizedConfigs = function createNormalizedConfigs(screen, routeConfig) {\n  var routeNames = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var initials = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  var parentScreens = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  var parentPattern = arguments.length > 5 ? arguments[5] : undefined;\n  var configs = [];\n  routeNames.push(screen);\n  parentScreens.push(screen);\n  var config = routeConfig[screen];\n  if (typeof config === \"string\") {\n    var pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n    configs.push(createConfigItem(screen, routeNames, pattern, config, false));\n  } else if (typeof config === \"object\") {\n    var _pattern;\n    var _route = config._route;\n    if (typeof config.path === \"string\") {\n      var _Object$keys;\n      if (config.exact && config.path === undefined) {\n        throw new Error(\"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\");\n      }\n      _pattern = config.exact !== true ? joinPaths(parentPattern || \"\", config.path || \"\") : config.path || \"\";\n      configs.push(createConfigItem(screen, routeNames, _pattern, config.path, config.screens ? !!((_Object$keys = Object.keys(config.screens)) != null && _Object$keys.length) : false, config.parse, _route));\n    }\n    if (config.screens) {\n      if (config.initialRouteName) {\n        initials.push({\n          initialRouteName: config.initialRouteName,\n          parentScreens: parentScreens\n        });\n      }\n      Object.keys(config.screens).forEach(function (nestedConfig) {\n        var _pattern2;\n        var result = createNormalizedConfigs(nestedConfig, config.screens, routeNames, initials, _toConsumableArray(parentScreens), (_pattern2 = _pattern) != null ? _pattern2 : parentPattern);\n        configs.push.apply(configs, _toConsumableArray(result));\n      });\n    }\n  }\n  routeNames.pop();\n  return configs;\n};\nfunction formatRegexPattern(it) {\n  it = it.replace(\" \", \"%20\");\n  if (it.startsWith(\":\")) {\n    return `(([^/]+\\\\/)${it.endsWith(\"?\") ? \"?\" : \"\"})`;\n  } else if (it.startsWith(\"*\")) {\n    return `((.*\\\\/)${it.endsWith(\"?\") ? \"?\" : \"\"})`;\n  }\n  if (matchGroupName(it) != null) {\n    return `(?:${escape(it)}\\\\/)?`;\n  }\n  return escape(it) + `\\\\/`;\n}\nvar createConfigItem = function createConfigItem(screen, routeNames, pattern, path, hasChildren, parse, _route) {\n  pattern = pattern.split(\"/\").filter(Boolean).join(\"/\");\n  var regex = pattern ? new RegExp(`^(${pattern.split(\"/\").map(formatRegexPattern).join(\"\")})$`) : undefined;\n  return {\n    screen: screen,\n    regex: regex,\n    pattern: pattern,\n    path: path,\n    routeNames: _toConsumableArray(routeNames),\n    parse: parse,\n    userReadableName: [].concat(_toConsumableArray(routeNames.slice(0, -1)), [path || screen]).join(\"/\"),\n    hasChildren: !!hasChildren,\n    _route: _route\n  };\n};\nvar findParseConfigForRoute = function findParseConfigForRoute(routeName, routeConfigs) {\n  for (var config of routeConfigs) {\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n  return undefined;\n};\nvar findInitialRoute = function findInitialRoute(routeName, parentScreens, initialRoutes) {\n  for (var config of initialRoutes) {\n    if (equalHeritage(parentScreens, config.parentScreens)) {\n      return routeName !== config.initialRouteName ? config.initialRouteName : undefined;\n    }\n  }\n  return undefined;\n};\nvar createStateObject = function createStateObject(initialRoute, route, isEmpty) {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{\n          name: initialRoute\n        }, route]\n      };\n    }\n    return {\n      routes: [route]\n    };\n  }\n  if (initialRoute) {\n    return {\n      index: 1,\n      routes: [{\n        name: initialRoute\n      }, _objectSpread(_objectSpread({}, route), {}, {\n        state: {\n          routes: []\n        }\n      })]\n    };\n  }\n  return {\n    routes: [_objectSpread(_objectSpread({}, route), {}, {\n      state: {\n        routes: []\n      }\n    })]\n  };\n};\nvar createNestedStateObject = function createNestedStateObject(path, routes, routeConfigs, initialRoutes) {\n  var route = routes.shift();\n  var parentScreens = [];\n  var initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n  parentScreens.push(route.name);\n  var state = createStateObject(initialRoute, route, routes.length === 0);\n  if (routes.length > 0) {\n    var nestedState = state;\n    while (route = routes.shift()) {\n      initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n      var nestedStateIndex = nestedState.index || nestedState.routes.length - 1;\n      nestedState.routes[nestedStateIndex].state = createStateObject(initialRoute, route, routes.length === 0);\n      if (routes.length > 0) {\n        nestedState = nestedState.routes[nestedStateIndex].state;\n      }\n      parentScreens.push(route.name);\n    }\n  }\n  route = findFocusedRoute(state);\n  route.path = stripGroupSegmentsFromPath(path);\n  var params = parseQueryParams(route.path, findParseConfigForRoute(route.name, routeConfigs));\n  if (params) {\n    var resolvedParams = _objectSpread(_objectSpread({}, route.params), params);\n    if (Object.keys(resolvedParams).length > 0) {\n      route.params = resolvedParams;\n    } else {\n      delete route.params;\n    }\n  }\n  return state;\n};\nvar parseQueryParams = function parseQueryParams(path, parseConfig) {\n  var query = path.split(\"?\")[1];\n  var params = queryString.parse(query);\n  if (parseConfig) {\n    Object.keys(params).forEach(function (name) {\n      if (Object.hasOwnProperty.call(parseConfig, name) && typeof params[name] === \"string\") {\n        params[name] = parseConfig[name](params[name]);\n      }\n    });\n  }\n  return Object.keys(params).length ? params : undefined;\n};","map":{"version":3,"names":["escape","queryString","URL","matchGroupName","stripGroupSegmentsFromPath","findFocusedRoute","validatePathConfig","getUrlWithReactNavigationConcessions","path","parsed","pathname","nonstandardPathname","replace","inputPathnameWithoutHash","getStateFromPath","options","_getMatchableRouteCon","getMatchableRouteConfigs","initialRoutes","configs","getStateFromPathWithConfigs","screens","Error","initialRouteName","push","parentScreens","converted","Object","keys","map","key","createNormalizedConfigs","flat","resolvedInitialPatterns","route","joinPaths","apply","_toConsumableArray","concat","convertedWithInitial","config","_objectSpread","isInitial","includes","routeNames","join","sort","sortConfigs","assertConfigDuplicates","reduce","acc","_config$regex$toStrin","_config$regex","indexedKey","regex","toString","pattern","alpha","hasChildren","a","b","intersects","length","every","it","i","last","split","pop","routeType","startsWith","userReadableName","assign","_defineProperty","localeCompare","screen","aParts","filter","part","bParts","Math","max","aWildCard","bWildCard","aSlug","bSlug","getStateFromEmptyPathWithConfigs","_ref","_leafNodes$find","leafNodes","value","match","find","test","undefined","routes","name","_route","createNestedStateObject","formattedPaths","matchAgainstConfigs","_ref2","_len","arguments","paths","Array","_key","p","Boolean","remaining","remainingPath","_loop","_config$pattern","matchedParams","_ref3","routeFromName","c","segments","params","forEach","_config$parse","_value","parse","combinedParams","r","hasCombinedParams","_ret","equalHeritage","routeConfig","initials","parentPattern","createConfigItem","_Object$keys","exact","nestedConfig","_pattern2","result","formatRegexPattern","endsWith","RegExp","slice","findParseConfigForRoute","routeName","routeConfigs","findInitialRoute","createStateObject","initialRoute","isEmpty","index","state","shift","nestedState","nestedStateIndex","parseQueryParams","resolvedParams","parseConfig","query","hasOwnProperty","call"],"sources":["C:/Users/acer/Documents/GitHub/collectify-front-end/node_modules/expo-router/src/fork/getStateFromPath.ts"],"sourcesContent":["import { PathConfigMap } from \"@react-navigation/core\";\r\nimport type {\r\n  InitialState,\r\n  NavigationState,\r\n  PartialState,\r\n} from \"@react-navigation/routers\";\r\nimport escape from \"escape-string-regexp\";\r\nimport * as queryString from \"query-string\";\r\nimport URL from \"url-parse\";\r\n\r\nimport { RouteNode } from \"../Route\";\r\nimport { matchGroupName, stripGroupSegmentsFromPath } from \"../matchers\";\r\nimport { findFocusedRoute } from \"./findFocusedRoute\";\r\nimport validatePathConfig from \"./validatePathConfig\";\r\n\r\ntype Options<ParamList extends object> = {\r\n  initialRouteName?: string;\r\n  screens: PathConfigMap<ParamList>;\r\n};\r\n\r\ntype ParseConfig = Record<string, (value: string) => any>;\r\n\r\ntype RouteConfig = {\r\n  isInitial?: boolean;\r\n  screen: string;\r\n  regex?: RegExp;\r\n  path: string;\r\n  pattern: string;\r\n  routeNames: string[];\r\n  parse?: ParseConfig;\r\n  hasChildren: boolean;\r\n  userReadableName: string;\r\n  _route?: RouteNode;\r\n};\r\n\r\ntype InitialRouteConfig = {\r\n  initialRouteName: string;\r\n  parentScreens: string[];\r\n};\r\n\r\nexport type ResultState = PartialState<NavigationState> & {\r\n  state?: ResultState;\r\n};\r\n\r\ntype ParsedRoute = {\r\n  name: string;\r\n  path?: string;\r\n  params?: Record<string, any> | undefined;\r\n};\r\n\r\nexport function getUrlWithReactNavigationConcessions(path: string) {\r\n  const parsed = new URL(path, \"https://acme.com\");\r\n  const pathname = parsed.pathname;\r\n\r\n  // Make sure there is a trailing slash\r\n  return {\r\n    // The slashes are at the end, not the beginning\r\n    nonstandardPathname:\r\n      pathname.replace(/^\\/+/g, \"\").replace(/\\/+$/g, \"\") + \"/\",\r\n    // React Navigation doesn't support hashes, so here\r\n    inputPathnameWithoutHash: path.replace(/#.*$/, \"\"),\r\n  };\r\n}\r\n\r\n/**\r\n * Utility to parse a path string to initial state object accepted by the container.\r\n * This is useful for deep linking when we need to handle the incoming URL.\r\n *\r\n * @example\r\n * ```js\r\n * getStateFromPath(\r\n *   '/chat/jane/42',\r\n *   {\r\n *     screens: {\r\n *       Chat: {\r\n *         path: 'chat/:author/:id',\r\n *         parse: { id: Number }\r\n *       }\r\n *     }\r\n *   }\r\n * )\r\n * ```\r\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\r\n * @param options Extra options to fine-tune how to parse the path.\r\n */\r\nexport default function getStateFromPath<ParamList extends object>(\r\n  path: string,\r\n  options?: Options<ParamList>\r\n): ResultState | undefined {\r\n  const { initialRoutes, configs } = getMatchableRouteConfigs(options);\r\n\r\n  return getStateFromPathWithConfigs(path, configs, initialRoutes);\r\n}\r\n\r\nexport function getMatchableRouteConfigs<ParamList extends object>(\r\n  options?: Options<ParamList>\r\n) {\r\n  if (options) {\r\n    validatePathConfig(options);\r\n  }\r\n\r\n  const screens = options?.screens;\r\n  // Expo Router disallows usage without a linking config.\r\n  if (!screens) {\r\n    throw Error(\r\n      \"You must pass a 'screens' object to 'getStateFromPath' to generate a path.\"\r\n    );\r\n  }\r\n\r\n  // This will be mutated...\r\n  const initialRoutes: InitialRouteConfig[] = [];\r\n\r\n  if (options?.initialRouteName) {\r\n    initialRoutes.push({\r\n      initialRouteName: options.initialRouteName,\r\n      parentScreens: [],\r\n    });\r\n  }\r\n\r\n  // Create a normalized configs array which will be easier to use.\r\n  const converted = Object.keys(screens)\r\n    .map((key) => createNormalizedConfigs(key, screens, [], initialRoutes))\r\n    .flat();\r\n\r\n  const resolvedInitialPatterns = initialRoutes.map((route) =>\r\n    joinPaths(...route.parentScreens, route.initialRouteName)\r\n  );\r\n\r\n  const convertedWithInitial = converted.map((config) => ({\r\n    ...config,\r\n    // TODO(EvanBacon): Probably a safer way to do this\r\n    // Mark initial routes to give them potential priority over other routes that match.\r\n    isInitial: resolvedInitialPatterns.includes(config.routeNames.join(\"/\")),\r\n  }));\r\n\r\n  // Sort in order of resolution. This is extremely important for the algorithm to work.\r\n  const configs = convertedWithInitial.sort(sortConfigs);\r\n\r\n  // Assert any duplicates before we start parsing.\r\n  assertConfigDuplicates(configs);\r\n\r\n  return { configs, initialRoutes };\r\n}\r\n\r\nfunction assertConfigDuplicates(configs: RouteConfig[]) {\r\n  // Check for duplicate patterns in the config\r\n  configs.reduce<Record<string, RouteConfig>>((acc, config) => {\r\n    // NOTE(EvanBacon): Uses the regex pattern as key to detect duplicate slugs.\r\n    const indexedKey = config.regex?.toString() ?? config.pattern;\r\n    const alpha = acc[indexedKey];\r\n    // NOTE(EvanBacon): Skips checking nodes that have children.\r\n    if (alpha && !alpha.hasChildren && !config.hasChildren) {\r\n      const a = alpha.routeNames;\r\n      const b = config.routeNames;\r\n\r\n      // It's not a problem if the path string omitted from a inner most screen\r\n      // For example, it's ok if a path resolves to `A > B > C` or `A > B`\r\n      const intersects =\r\n        a.length > b.length\r\n          ? b.every((it, i) => a[i] === it)\r\n          : a.every((it, i) => b[i] === it);\r\n\r\n      if (!intersects) {\r\n        // NOTE(EvanBacon): Adds more context to the error message since we know about the\r\n        // file-based routing.\r\n        const last = config.pattern.split(\"/\").pop();\r\n        const routeType = last?.startsWith(\":\")\r\n          ? \"dynamic route\"\r\n          : last?.startsWith(\"*\")\r\n          ? \"dynamic-rest route\"\r\n          : \"route\";\r\n        throw new Error(\r\n          `The ${routeType} pattern '${\r\n            config.pattern || \"/\"\r\n          }' resolves to both '${alpha.userReadableName}' and '${\r\n            config.userReadableName\r\n          }'. Patterns must be unique and cannot resolve to more than one route.`\r\n        );\r\n      }\r\n    }\r\n\r\n    return Object.assign(acc, {\r\n      [indexedKey]: config,\r\n    });\r\n  }, {});\r\n}\r\n\r\nfunction sortConfigs(a: RouteConfig, b: RouteConfig): number {\r\n  // Sort config so that:\r\n  // - the most exhaustive ones are always at the beginning\r\n  // - patterns with wildcard are always at the end\r\n\r\n  // If 2 patterns are same, move the one with less route names up\r\n  // This is an error state, so it's only useful for consistent error messages\r\n  if (a.pattern === b.pattern) {\r\n    return b.routeNames.join(\">\").localeCompare(a.routeNames.join(\">\"));\r\n  }\r\n\r\n  // If one of the patterns starts with the other, it's more exhaustive\r\n  // So move it up\r\n  if (\r\n    a.pattern.startsWith(b.pattern) &&\r\n    // NOTE(EvanBacon): This is a hack to make sure that `*` is always at the end\r\n    b.screen !== \"index\"\r\n  ) {\r\n    return -1;\r\n  }\r\n\r\n  if (b.pattern.startsWith(a.pattern) && a.screen !== \"index\") {\r\n    return 1;\r\n  }\r\n\r\n  // NOTE(EvanBacon): Here we append `index` if the screen was `index` so the length is the same\r\n  // as a slug or wildcard when nested more than one level deep.\r\n  // This is so we can compare the length of the pattern, e.g. `foo/*` > `foo` vs `*` < ``.\r\n  const aParts = a.pattern\r\n    .split(\"/\")\r\n    // Strip out group names to ensure they don't affect the priority.\r\n    .filter((part) => matchGroupName(part) == null);\r\n  if (a.screen === \"index\") {\r\n    aParts.push(\"index\");\r\n  }\r\n\r\n  const bParts = b.pattern\r\n    .split(\"/\")\r\n    .filter((part) => matchGroupName(part) == null);\r\n  if (b.screen === \"index\") {\r\n    bParts.push(\"index\");\r\n  }\r\n\r\n  for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {\r\n    // if b is longer, b get higher priority\r\n    if (aParts[i] == null) {\r\n      return 1;\r\n    }\r\n    // if a is longer, a get higher priority\r\n    if (bParts[i] == null) {\r\n      return -1;\r\n    }\r\n    const aWildCard = aParts[i].startsWith(\"*\");\r\n    const bWildCard = bParts[i].startsWith(\"*\");\r\n    // if both are wildcard we compare next component\r\n    if (aWildCard && bWildCard) {\r\n      continue;\r\n    }\r\n    // if only a is wild card, b get higher priority\r\n    if (aWildCard) {\r\n      return 1;\r\n    }\r\n    // if only b is wild card, a get higher priority\r\n    if (bWildCard) {\r\n      return -1;\r\n    }\r\n\r\n    const aSlug = aParts[i].startsWith(\":\");\r\n    const bSlug = bParts[i].startsWith(\":\");\r\n    // if both are wildcard we compare next component\r\n    if (aSlug && bSlug) {\r\n      continue;\r\n    }\r\n    // if only a is wild card, b get higher priority\r\n    if (aSlug) {\r\n      return 1;\r\n    }\r\n    // if only b is wild card, a get higher priority\r\n    if (bSlug) {\r\n      return -1;\r\n    }\r\n  }\r\n\r\n  // Sort initial routes with a higher priority than routes which will push more screens\r\n  // this ensures shared routes go to the shortest path.\r\n  if (a.isInitial && !b.isInitial) {\r\n    return -1;\r\n  }\r\n  if (!a.isInitial && b.isInitial) {\r\n    return 1;\r\n  }\r\n\r\n  return bParts.length - aParts.length;\r\n}\r\n\r\nfunction getStateFromEmptyPathWithConfigs(\r\n  path: string,\r\n  configs: RouteConfig[],\r\n  initialRoutes: InitialRouteConfig[]\r\n): ResultState | undefined {\r\n  // We need to add special handling of empty path so navigation to empty path also works\r\n  // When handling empty path, we should only look at the root level config\r\n\r\n  // NOTE(EvanBacon): We only care about matching leaf nodes.\r\n  const leafNodes = configs\r\n    .filter((config) => !config.hasChildren)\r\n    .map((value) => {\r\n      return {\r\n        ...value,\r\n        // Collapse all levels of group segments before testing.\r\n        // This enables `app/(one)/(two)/index.js` to be matched.\r\n        path: stripGroupSegmentsFromPath(value.path),\r\n      };\r\n    });\r\n\r\n  const match =\r\n    leafNodes.find(\r\n      (config) =>\r\n        // NOTE(EvanBacon): Test leaf node index routes that either don't have a regex or match an empty string.\r\n        config.path === \"\" && (!config.regex || config.regex.test(\"\"))\r\n    ) ??\r\n    leafNodes.find(\r\n      (config) =>\r\n        // NOTE(EvanBacon): Test leaf node dynamic routes that match an empty string.\r\n        config.path.startsWith(\":\") && config.regex!.test(\"\")\r\n    ) ??\r\n    // NOTE(EvanBacon): Test leaf node deep dynamic routes that match a slash.\r\n    // This should be done last to enable dynamic routes having a higher priority.\r\n    leafNodes.find(\r\n      (config) => config.path.startsWith(\"*\") && config.regex!.test(\"/\")\r\n    );\r\n\r\n  if (!match) {\r\n    return undefined;\r\n  }\r\n\r\n  const routes = match.routeNames.map((name) => {\r\n    if (!match._route) {\r\n      return { name };\r\n    }\r\n    return {\r\n      name,\r\n      _route: match._route,\r\n    };\r\n  });\r\n\r\n  return createNestedStateObject(path, routes, configs, initialRoutes);\r\n}\r\n\r\nfunction getStateFromPathWithConfigs(\r\n  path: string,\r\n  configs: RouteConfig[],\r\n  initialRoutes: InitialRouteConfig[]\r\n): ResultState | undefined {\r\n  const formattedPaths = getUrlWithReactNavigationConcessions(path);\r\n\r\n  if (formattedPaths.nonstandardPathname === \"/\") {\r\n    return getStateFromEmptyPathWithConfigs(\r\n      formattedPaths.inputPathnameWithoutHash,\r\n      configs,\r\n      initialRoutes\r\n    );\r\n  }\r\n\r\n  // We match the whole path against the regex instead of segments\r\n  // This makes sure matches such as wildcard will catch any unmatched routes, even if nested\r\n  const routes = matchAgainstConfigs(\r\n    formattedPaths.nonstandardPathname,\r\n    configs\r\n  );\r\n\r\n  if (routes == null) {\r\n    return undefined;\r\n  }\r\n  // This will always be empty if full path matched\r\n  return createNestedStateObject(\r\n    formattedPaths.inputPathnameWithoutHash,\r\n    routes,\r\n    configs,\r\n    initialRoutes\r\n  );\r\n}\r\n\r\nconst joinPaths = (...paths: string[]): string =>\r\n  ([] as string[])\r\n    .concat(...paths.map((p) => p.split(\"/\")))\r\n    .filter(Boolean)\r\n    .join(\"/\");\r\n\r\nfunction matchAgainstConfigs(\r\n  remaining: string,\r\n  configs: RouteConfig[]\r\n): ParsedRoute[] | undefined {\r\n  let routes: ParsedRoute[] | undefined;\r\n  let remainingPath = remaining;\r\n\r\n  // Go through all configs, and see if the next path segment matches our regex\r\n  for (const config of configs) {\r\n    if (!config.regex) {\r\n      continue;\r\n    }\r\n\r\n    const match = remainingPath.match(config.regex);\r\n\r\n    // If our regex matches, we need to extract params from the path\r\n    if (!match) {\r\n      continue;\r\n    }\r\n\r\n    // TODO: Add support for wildcard routes\r\n    const matchedParams = config.pattern\r\n      ?.split(\"/\")\r\n      .filter((p) => p.match(/^[:*]/))\r\n      .reduce<Record<string, any>>((acc, p, i) => {\r\n        if (p.match(/^\\*/)) {\r\n          return {\r\n            ...acc,\r\n            [p]: match![(i + 1) * 2], //?.replace(/\\//, \"\"),\r\n          };\r\n        }\r\n        return Object.assign(acc, {\r\n          // The param segments appear every second item starting from 2 in the regex match result.\r\n          // This will only work if we ensure groups aren't included in the match.\r\n          [p]: match![(i + 1) * 2]?.replace(/\\//, \"\"),\r\n        });\r\n      }, {});\r\n\r\n    const routeFromName = (name: string) => {\r\n      const config = configs.find((c) => c.screen === name);\r\n      if (!config?.path) {\r\n        return { name };\r\n      }\r\n\r\n      const segments = config.path.split(\"/\");\r\n\r\n      const params: Record<string, any> = {};\r\n\r\n      segments\r\n        .filter((p) => p.match(/^[:*]/))\r\n        .forEach((p) => {\r\n          let value = matchedParams[p];\r\n          if (value) {\r\n            if (p.match(/^\\*/)) {\r\n              // Convert to an array before providing as a route.\r\n              value = value?.split(\"/\").filter(Boolean);\r\n            }\r\n\r\n            const key = p.replace(/^[:*]/, \"\").replace(/\\?$/, \"\");\r\n            params[key] = config.parse?.[key]\r\n              ? config.parse[key](value)\r\n              : value;\r\n          }\r\n        });\r\n\r\n      if (params && Object.keys(params).length) {\r\n        return { name, params };\r\n      }\r\n\r\n      return { name };\r\n    };\r\n\r\n    routes = config.routeNames.map((name) => {\r\n      if (!config._route) {\r\n        return { ...routeFromName(name) };\r\n      }\r\n      return {\r\n        ...routeFromName(name),\r\n        _route: config._route,\r\n      };\r\n    });\r\n\r\n    // TODO(EvanBacon): Maybe we should warn / assert if multiple slugs use the same param name.\r\n    const combinedParams = routes.reduce<Record<string, any>>(\r\n      (acc, r) => Object.assign(acc, r.params),\r\n      {}\r\n    );\r\n\r\n    const hasCombinedParams = Object.keys(combinedParams).length > 0;\r\n\r\n    // Combine all params so a route `[foo]/[bar]/other.js` has access to `{ foo, bar }`\r\n    routes = routes.map((r) => {\r\n      if (hasCombinedParams) {\r\n        r.params = combinedParams;\r\n      }\r\n      return r;\r\n    });\r\n\r\n    remainingPath = remainingPath.replace(match[1], \"\");\r\n\r\n    break;\r\n  }\r\n\r\n  return routes;\r\n}\r\n\r\nfunction equalHeritage(a: string[], b: string[]): boolean {\r\n  if (a.length !== b.length) {\r\n    return false;\r\n  }\r\n  for (let i = 0; i < a.length; i++) {\r\n    if (a[i].localeCompare(b[i]) !== 0) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nconst createNormalizedConfigs = (\r\n  screen: string,\r\n  routeConfig: PathConfigMap<object>,\r\n  routeNames: string[] = [],\r\n  initials: InitialRouteConfig[] = [],\r\n  parentScreens: string[] = [],\r\n  parentPattern?: string\r\n): RouteConfig[] => {\r\n  const configs: RouteConfig[] = [];\r\n\r\n  routeNames.push(screen);\r\n\r\n  parentScreens.push(screen);\r\n\r\n  const config = (routeConfig as any)[screen];\r\n\r\n  if (typeof config === \"string\") {\r\n    // TODO: This should never happen with the addition of `_route`\r\n\r\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\r\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\r\n\r\n    configs.push(createConfigItem(screen, routeNames, pattern, config, false));\r\n  } else if (typeof config === \"object\") {\r\n    let pattern: string | undefined;\r\n\r\n    const { _route } = config;\r\n    // if an object is specified as the value (e.g. Foo: { ... }),\r\n    // it can have `path` property and\r\n    // it could have `screens` prop which has nested configs\r\n    if (typeof config.path === \"string\") {\r\n      if (config.exact && config.path === undefined) {\r\n        throw new Error(\r\n          \"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\"\r\n        );\r\n      }\r\n\r\n      pattern =\r\n        config.exact !== true\r\n          ? joinPaths(parentPattern || \"\", config.path || \"\")\r\n          : config.path || \"\";\r\n\r\n      configs.push(\r\n        createConfigItem(\r\n          screen,\r\n          routeNames,\r\n          pattern!,\r\n          config.path,\r\n          config.screens ? !!Object.keys(config.screens)?.length : false,\r\n          config.parse,\r\n          _route\r\n        )\r\n      );\r\n    }\r\n\r\n    if (config.screens) {\r\n      // property `initialRouteName` without `screens` has no purpose\r\n      if (config.initialRouteName) {\r\n        initials.push({\r\n          initialRouteName: config.initialRouteName,\r\n          parentScreens,\r\n        });\r\n      }\r\n\r\n      Object.keys(config.screens).forEach((nestedConfig) => {\r\n        const result = createNormalizedConfigs(\r\n          nestedConfig,\r\n          config.screens as PathConfigMap<object>,\r\n          routeNames,\r\n          initials,\r\n          [...parentScreens],\r\n          pattern ?? parentPattern\r\n        );\r\n\r\n        configs.push(...result);\r\n      });\r\n    }\r\n  }\r\n\r\n  routeNames.pop();\r\n\r\n  return configs;\r\n};\r\n\r\nfunction formatRegexPattern(it: string): string {\r\n  // Allow spaces in file path names.\r\n  it = it.replace(\" \", \"%20\");\r\n\r\n  if (it.startsWith(\":\")) {\r\n    // TODO: Remove unused match group\r\n    return `(([^/]+\\\\/)${it.endsWith(\"?\") ? \"?\" : \"\"})`;\r\n  } else if (it.startsWith(\"*\")) {\r\n    return `((.*\\\\/)${it.endsWith(\"?\") ? \"?\" : \"\"})`;\r\n  }\r\n\r\n  // Strip groups from the matcher\r\n  if (matchGroupName(it) != null) {\r\n    // Groups are optional segments\r\n    // this enables us to match `/bar` and `/(foo)/bar` for the same route\r\n    // NOTE(EvanBacon): Ignore this match in the regex to avoid capturing the group\r\n    return `(?:${escape(it)}\\\\/)?`;\r\n  }\r\n\r\n  return escape(it) + `\\\\/`;\r\n}\r\n\r\nconst createConfigItem = (\r\n  screen: string,\r\n  routeNames: string[],\r\n  pattern: string,\r\n  path: string,\r\n  hasChildren?: boolean,\r\n  parse?: ParseConfig,\r\n  _route?: any\r\n): RouteConfig => {\r\n  // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\r\n  pattern = pattern.split(\"/\").filter(Boolean).join(\"/\");\r\n\r\n  const regex = pattern\r\n    ? new RegExp(`^(${pattern.split(\"/\").map(formatRegexPattern).join(\"\")})$`)\r\n    : undefined;\r\n\r\n  return {\r\n    screen,\r\n    regex,\r\n    pattern,\r\n    path,\r\n    // The routeNames array is mutated, so copy it to keep the current state\r\n    routeNames: [...routeNames],\r\n    parse,\r\n    userReadableName: [...routeNames.slice(0, -1), path || screen].join(\"/\"),\r\n    hasChildren: !!hasChildren,\r\n    _route,\r\n  };\r\n};\r\n\r\nconst findParseConfigForRoute = (\r\n  routeName: string,\r\n  routeConfigs: RouteConfig[]\r\n): ParseConfig | undefined => {\r\n  for (const config of routeConfigs) {\r\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\r\n      return config.parse;\r\n    }\r\n  }\r\n\r\n  return undefined;\r\n};\r\n\r\n// Try to find an initial route connected with the one passed\r\nconst findInitialRoute = (\r\n  routeName: string,\r\n  parentScreens: string[],\r\n  initialRoutes: InitialRouteConfig[]\r\n): string | undefined => {\r\n  for (const config of initialRoutes) {\r\n    if (equalHeritage(parentScreens, config.parentScreens)) {\r\n      // If the parents are the same but the route name doesn't match the initial route\r\n      // then we return the initial route.\r\n      return routeName !== config.initialRouteName\r\n        ? config.initialRouteName\r\n        : undefined;\r\n    }\r\n  }\r\n  return undefined;\r\n};\r\n\r\n// returns state object with values depending on whether\r\n// it is the end of state and if there is initialRoute for this level\r\nconst createStateObject = (\r\n  initialRoute: string | undefined,\r\n  route: ParsedRoute,\r\n  isEmpty: boolean\r\n): InitialState => {\r\n  if (isEmpty) {\r\n    if (initialRoute) {\r\n      return {\r\n        index: 1,\r\n        routes: [{ name: initialRoute }, route],\r\n      };\r\n    }\r\n    return {\r\n      routes: [route],\r\n    };\r\n  }\r\n\r\n  if (initialRoute) {\r\n    return {\r\n      index: 1,\r\n      routes: [{ name: initialRoute }, { ...route, state: { routes: [] } }],\r\n    };\r\n  }\r\n  return {\r\n    routes: [{ ...route, state: { routes: [] } }],\r\n  };\r\n};\r\n\r\nconst createNestedStateObject = (\r\n  path: string,\r\n  routes: ParsedRoute[],\r\n  routeConfigs: RouteConfig[],\r\n  initialRoutes: InitialRouteConfig[]\r\n) => {\r\n  let route = routes.shift() as ParsedRoute;\r\n  const parentScreens: string[] = [];\r\n\r\n  let initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\r\n\r\n  parentScreens.push(route.name);\r\n\r\n  const state: InitialState = createStateObject(\r\n    initialRoute,\r\n    route,\r\n    routes.length === 0\r\n  );\r\n\r\n  if (routes.length > 0) {\r\n    let nestedState = state;\r\n\r\n    while ((route = routes.shift() as ParsedRoute)) {\r\n      initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\r\n\r\n      const nestedStateIndex =\r\n        nestedState.index || nestedState.routes.length - 1;\r\n\r\n      nestedState.routes[nestedStateIndex].state = createStateObject(\r\n        initialRoute,\r\n        route,\r\n        routes.length === 0\r\n      );\r\n\r\n      if (routes.length > 0) {\r\n        nestedState = nestedState.routes[nestedStateIndex]\r\n          .state as InitialState;\r\n      }\r\n\r\n      parentScreens.push(route.name);\r\n    }\r\n  }\r\n\r\n  route = findFocusedRoute(state) as ParsedRoute;\r\n\r\n  // Remove groups from the path while preserving a trailing slash.\r\n  route.path = stripGroupSegmentsFromPath(path);\r\n\r\n  const params = parseQueryParams(\r\n    route.path,\r\n    findParseConfigForRoute(route.name, routeConfigs)\r\n  );\r\n\r\n  if (params) {\r\n    const resolvedParams = { ...route.params, ...params };\r\n    if (Object.keys(resolvedParams).length > 0) {\r\n      route.params = resolvedParams;\r\n    } else {\r\n      delete route.params;\r\n    }\r\n  }\r\n\r\n  return state;\r\n};\r\n\r\nconst parseQueryParams = (\r\n  path: string,\r\n  parseConfig?: Record<string, (value: string) => any>\r\n) => {\r\n  const query = path.split(\"?\")[1];\r\n  const params = queryString.parse(query);\r\n\r\n  if (parseConfig) {\r\n    Object.keys(params).forEach((name) => {\r\n      if (\r\n        Object.hasOwnProperty.call(parseConfig, name) &&\r\n        typeof params[name] === \"string\"\r\n      ) {\r\n        params[name] = parseConfig[name](params[name] as string);\r\n      }\r\n    });\r\n  }\r\n\r\n  return Object.keys(params).length ? params : undefined;\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nexport function getRouteInfoFromState(getPathFromState, state) {\n  var _getPathFromState = getPathFromState(state, false),\n    path = _getPathFromState.path;\n  var qualified = getPathFromState(state, true);\n  return _objectSpread({\n    unstable_globalHref: path,\n    pathname: path.split(\"?\")[\"0\"]\n  }, getNormalizedStatePath(qualified));\n}\nexport function getNormalizedStatePath(_ref) {\n  var statePath = _ref.path,\n    params = _ref.params;\n  var _statePath$split = statePath.split(\"?\"),\n    _statePath$split2 = _slicedToArray(_statePath$split, 1),\n    pathname = _statePath$split2[0];\n  return {\n    segments: pathname.split(\"/\").filter(Boolean).map(decodeURIComponent),\n    params: Object.entries(params).reduce(function (prev, _ref2) {\n      var _ref3 = _slicedToArray(_ref2, 2),\n        key = _ref3[0],\n        value = _ref3[1];\n      if (Array.isArray(value)) {\n        prev[key] = value.map(decodeURIComponent);\n      } else {\n        prev[key] = decodeURIComponent(value);\n      }\n      return prev;\n    }, {})\n  };\n}","map":{"version":3,"names":["getRouteInfoFromState","getPathFromState","state","_getPathFromState","path","qualified","_objectSpread","unstable_globalHref","pathname","split","getNormalizedStatePath","_ref","statePath","params","_statePath$split","_statePath$split2","_slicedToArray","segments","filter","Boolean","map","decodeURIComponent","Object","entries","reduce","prev","_ref2","_ref3","key","value","Array","isArray"],"sources":["C:/Users/User/Documents/GitHub/Capstone/collectify/collectify-front-end/node_modules/expo-router/src/LocationProvider.tsx"],"sourcesContent":["import { State } from \"./fork/getPathFromState\";\r\n\r\ntype SearchParams = Record<string, string | string[]>;\r\n\r\nexport type UrlObject = {\r\n  unstable_globalHref: string;\r\n  pathname: string;\r\n  readonly params: SearchParams;\r\n  segments: string[];\r\n};\r\n\r\nexport function getRouteInfoFromState(\r\n  getPathFromState: (\r\n    state: State,\r\n    asPath: boolean\r\n  ) => { path: string; params: any },\r\n  state: State\r\n): UrlObject {\r\n  const { path } = getPathFromState(state, false);\r\n  const qualified = getPathFromState(state, true);\r\n  return {\r\n    // TODO: This may have a predefined origin attached in the future.\r\n    unstable_globalHref: path,\r\n    pathname: path.split(\"?\")[\"0\"],\r\n    ...getNormalizedStatePath(qualified),\r\n  };\r\n}\r\n\r\n// TODO: Split up getPathFromState to return all this info at once.\r\nexport function getNormalizedStatePath({\r\n  path: statePath,\r\n  params,\r\n}: {\r\n  path: string;\r\n  params: any;\r\n}): Pick<UrlObject, \"segments\" | \"params\"> {\r\n  const [pathname] = statePath.split(\"?\");\r\n  return {\r\n    // Strip empty path at the start\r\n    segments: pathname.split(\"/\").filter(Boolean).map(decodeURIComponent),\r\n    // TODO: This is not efficient, we should generate based on the state instead\r\n    // of converting to string then back to object\r\n    params: Object.entries(params).reduce((prev, [key, value]) => {\r\n      if (Array.isArray(value)) {\r\n        prev[key] = value.map(decodeURIComponent);\r\n      } else {\r\n        prev[key] = decodeURIComponent(value as string);\r\n      }\r\n      return prev;\r\n    }, {} as SearchParams),\r\n  };\r\n}\r\n"],"mappings":";;;;AAWA,OAAO,SAASA,qBAAqBA,CACnCC,gBAGkC,EAClCC,KAAY,EACD;EACX,IAAAC,iBAAA,GAAiBF,gBAAgB,CAACC,KAAK,EAAE,KAAK,CAAC;IAAvCE,IAAI,GAAAD,iBAAA,CAAJC,IAAI;EACZ,IAAMC,SAAS,GAAGJ,gBAAgB,CAACC,KAAK,EAAE,IAAI,CAAC;EAC/C,OAAAI,aAAA;IAEEC,mBAAmB,EAAEH,IAAI;IACzBI,QAAQ,EAAEJ,IAAI,CAACK,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG;EAAC,GAC3BC,sBAAsB,CAACL,SAAS,CAAC;AAExC;AAGA,OAAO,SAASK,sBAAsBA,CAAAC,IAAA,EAMK;EAAA,IALnCC,SAAS,GAAAD,IAAA,CAAfP,IAAI;IACJS,MAAM,GAAAF,IAAA,CAANE,MAAM;EAKN,IAAAC,gBAAA,GAAmBF,SAAS,CAACH,KAAK,CAAC,GAAG,CAAC;IAAAM,iBAAA,GAAAC,cAAA,CAAAF,gBAAA;IAAhCN,QAAQ,GAAAO,iBAAA;EACf,OAAO;IAELE,QAAQ,EAAET,QAAQ,CAACC,KAAK,CAAC,GAAG,CAAC,CAACS,MAAM,CAACC,OAAO,CAAC,CAACC,GAAG,CAACC,kBAAkB,CAAC;IAGrER,MAAM,EAAES,MAAM,CAACC,OAAO,CAACV,MAAM,CAAC,CAACW,MAAM,CAAC,UAACC,IAAI,EAAAC,KAAA,EAAmB;MAAA,IAAAC,KAAA,GAAAX,cAAA,CAAAU,KAAA;QAAhBE,GAAG,GAAAD,KAAA;QAAEE,KAAK,GAAAF,KAAA;MACtD,IAAIG,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,EAAE;QACxBJ,IAAI,CAACG,GAAG,CAAC,GAAGC,KAAK,CAACT,GAAG,CAACC,kBAAkB,CAAC;MAC3C,CAAC,MAAM;QACLI,IAAI,CAACG,GAAG,CAAC,GAAGP,kBAAkB,CAACQ,KAAe,CAAC;MACjD;MACA,OAAOJ,IAAI;IACb,CAAC,EAAE,CAAC,CAAiB;EACvB,CAAC;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}
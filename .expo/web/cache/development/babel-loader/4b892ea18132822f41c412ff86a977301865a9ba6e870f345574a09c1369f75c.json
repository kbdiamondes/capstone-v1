{"ast":null,"code":"import { matchDeepDynamicRouteName, matchDynamicName } from \"./matchers\";\nfunction convertDynamicRouteToReactNavigation(segment) {\n  if (segment === \"index\") {\n    return \"\";\n  }\n  var rest = matchDeepDynamicRouteName(segment);\n  if (rest != null) {\n    return \"*\" + rest;\n  }\n  var dynamicName = matchDynamicName(segment);\n  if (dynamicName != null) {\n    return `:${dynamicName}`;\n  }\n  return segment;\n}\nfunction parseRouteSegments(segments) {\n  return segments.split(\"/\").map(convertDynamicRouteToReactNavigation).filter(Boolean).join(\"/\");\n}\nfunction convertRouteNodeToScreen(node, metaOnly) {\n  var path = parseRouteSegments(node.route);\n  if (!node.children.length) {\n    if (!metaOnly) {\n      return {\n        path: path,\n        screens: {},\n        _route: node\n      };\n    }\n    return path;\n  }\n  var screens = getReactNavigationScreensConfig(node.children, metaOnly);\n  var screen = {\n    path: path,\n    screens: screens,\n    initialRouteName: node.initialRouteName\n  };\n  if (!metaOnly) {\n    screen._route = node;\n  }\n  return screen;\n}\nexport function getReactNavigationScreensConfig(nodes, metaOnly) {\n  return Object.fromEntries(nodes.map(function (node) {\n    return [node.route, convertRouteNodeToScreen(node, metaOnly)];\n  }));\n}\nexport function getReactNavigationConfig(routes, metaOnly) {\n  return {\n    initialRouteName: routes.initialRouteName,\n    screens: getReactNavigationScreensConfig(routes.children, metaOnly)\n  };\n}","map":{"version":3,"names":["matchDeepDynamicRouteName","matchDynamicName","convertDynamicRouteToReactNavigation","segment","rest","dynamicName","parseRouteSegments","segments","split","map","filter","Boolean","join","convertRouteNodeToScreen","node","metaOnly","path","route","children","length","screens","_route","getReactNavigationScreensConfig","screen","initialRouteName","nodes","Object","fromEntries","getReactNavigationConfig","routes"],"sources":["C:/Users/User/Documents/GitHub/Capstone/collectify/collectify-front-end/node_modules/expo-router/src/getReactNavigationConfig.ts"],"sourcesContent":["import type { RouteNode } from \"./Route\";\r\nimport { matchDeepDynamicRouteName, matchDynamicName } from \"./matchers\";\r\n\r\nexport type Screen =\r\n  | string\r\n  | {\r\n      path: string;\r\n      screens: Record<string, Screen>;\r\n      _route?: RouteNode;\r\n      initialRouteName?: string;\r\n    };\r\n\r\n// `[page]` -> `:page`\r\n// `page` -> `page`\r\nfunction convertDynamicRouteToReactNavigation(segment: string): string {\r\n  // NOTE(EvanBacon): To support shared routes we preserve group segments.\r\n  if (segment === \"index\") {\r\n    return \"\";\r\n  }\r\n\r\n  const rest = matchDeepDynamicRouteName(segment);\r\n  if (rest != null) {\r\n    return \"*\" + rest;\r\n  }\r\n  const dynamicName = matchDynamicName(segment);\r\n\r\n  if (dynamicName != null) {\r\n    return `:${dynamicName}`;\r\n  }\r\n\r\n  return segment;\r\n}\r\n\r\nfunction parseRouteSegments(segments: string): string {\r\n  return (\r\n    // NOTE(EvanBacon): When there are nested routes without layouts\r\n    // the node.route will be something like `app/home/index`\r\n    // this needs to be split to ensure each segment is parsed correctly.\r\n    segments\r\n      .split(\"/\")\r\n      // Convert each segment to a React Navigation format.\r\n      .map(convertDynamicRouteToReactNavigation)\r\n      // Remove any empty paths from groups or index routes.\r\n      .filter(Boolean)\r\n      // Join to return as a path.\r\n      .join(\"/\")\r\n  );\r\n}\r\n\r\nfunction convertRouteNodeToScreen(node: RouteNode, metaOnly: boolean): Screen {\r\n  const path = parseRouteSegments(node.route);\r\n  if (!node.children.length) {\r\n    if (!metaOnly) {\r\n      return {\r\n        path,\r\n        screens: {},\r\n        _route: node,\r\n      };\r\n    }\r\n    return path;\r\n  }\r\n  const screens = getReactNavigationScreensConfig(node.children, metaOnly);\r\n\r\n  const screen: Screen = {\r\n    path,\r\n    screens,\r\n    // NOTE(EvanBacon): This is bad because it forces all Layout Routes\r\n    // to be loaded into memory. We should move towards a system where\r\n    // the initial route name is either loaded asynchronously in the Layout Route\r\n    // or defined via a file system convention.\r\n    initialRouteName: node.initialRouteName,\r\n  };\r\n\r\n  if (!metaOnly) {\r\n    screen._route = node;\r\n  }\r\n\r\n  return screen;\r\n}\r\n\r\nexport function getReactNavigationScreensConfig(\r\n  nodes: RouteNode[],\r\n  metaOnly: boolean\r\n): Record<string, Screen> {\r\n  return Object.fromEntries(\r\n    nodes.map(\r\n      (node) => [node.route, convertRouteNodeToScreen(node, metaOnly)] as const\r\n    )\r\n  );\r\n}\r\n\r\nexport function getReactNavigationConfig(\r\n  routes: RouteNode,\r\n  metaOnly: boolean\r\n): {\r\n  initialRouteName?: string;\r\n  screens: Record<string, Screen>;\r\n} {\r\n  return {\r\n    initialRouteName: routes.initialRouteName,\r\n    screens: getReactNavigationScreensConfig(routes.children, metaOnly),\r\n  };\r\n}\r\n"],"mappings":"AACA,SAASA,yBAAyB,EAAEC,gBAAgB;AAapD,SAASC,oCAAoCA,CAACC,OAAe,EAAU;EAErE,IAAIA,OAAO,KAAK,OAAO,EAAE;IACvB,OAAO,EAAE;EACX;EAEA,IAAMC,IAAI,GAAGJ,yBAAyB,CAACG,OAAO,CAAC;EAC/C,IAAIC,IAAI,IAAI,IAAI,EAAE;IAChB,OAAO,GAAG,GAAGA,IAAI;EACnB;EACA,IAAMC,WAAW,GAAGJ,gBAAgB,CAACE,OAAO,CAAC;EAE7C,IAAIE,WAAW,IAAI,IAAI,EAAE;IACvB,OAAQ,IAAGA,WAAY,EAAC;EAC1B;EAEA,OAAOF,OAAO;AAChB;AAEA,SAASG,kBAAkBA,CAACC,QAAgB,EAAU;EACpD,OAIEA,QAAQ,CACLC,KAAK,CAAC,GAAG,CAAC,CAEVC,GAAG,CAACP,oCAAoC,CAAC,CAEzCQ,MAAM,CAACC,OAAO,CAAC,CAEfC,IAAI,CAAC,GAAG,CAAC;AAEhB;AAEA,SAASC,wBAAwBA,CAACC,IAAe,EAAEC,QAAiB,EAAU;EAC5E,IAAMC,IAAI,GAAGV,kBAAkB,CAACQ,IAAI,CAACG,KAAK,CAAC;EAC3C,IAAI,CAACH,IAAI,CAACI,QAAQ,CAACC,MAAM,EAAE;IACzB,IAAI,CAACJ,QAAQ,EAAE;MACb,OAAO;QACLC,IAAI,EAAJA,IAAI;QACJI,OAAO,EAAE,CAAC,CAAC;QACXC,MAAM,EAAEP;MACV,CAAC;IACH;IACA,OAAOE,IAAI;EACb;EACA,IAAMI,OAAO,GAAGE,+BAA+B,CAACR,IAAI,CAACI,QAAQ,EAAEH,QAAQ,CAAC;EAExE,IAAMQ,MAAc,GAAG;IACrBP,IAAI,EAAJA,IAAI;IACJI,OAAO,EAAPA,OAAO;IAKPI,gBAAgB,EAAEV,IAAI,CAACU;EACzB,CAAC;EAED,IAAI,CAACT,QAAQ,EAAE;IACbQ,MAAM,CAACF,MAAM,GAAGP,IAAI;EACtB;EAEA,OAAOS,MAAM;AACf;AAEA,OAAO,SAASD,+BAA+BA,CAC7CG,KAAkB,EAClBV,QAAiB,EACO;EACxB,OAAOW,MAAM,CAACC,WAAW,CACvBF,KAAK,CAAChB,GAAG,CACP,UAACK,IAAI;IAAA,OAAK,CAACA,IAAI,CAACG,KAAK,EAAEJ,wBAAwB,CAACC,IAAI,EAAEC,QAAQ,CAAC,CAAC;EAAA,CAClE,CACF,CAAC;AACH;AAEA,OAAO,SAASa,wBAAwBA,CACtCC,MAAiB,EACjBd,QAAiB,EAIjB;EACA,OAAO;IACLS,gBAAgB,EAAEK,MAAM,CAACL,gBAAgB;IACzCJ,OAAO,EAAEE,+BAA+B,CAACO,MAAM,CAACX,QAAQ,EAAEH,QAAQ;EACpE,CAAC;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}